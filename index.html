<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640" />

    <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
    <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>Lampas by Linguae</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/Linguae/Lampas">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>Lampas</h1>
            <h2>A Lisp dialect</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/Linguae/Lampas/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/Linguae/Lampas/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h1>
<a name="a-lisp" class="anchor" href="#a-lisp"><span class="octicon octicon-link"></span></a>A Lisp</h1>

<p>Lampas is my first Lisp; currently its unique features include continuations, macros, and some syntactic sugar.</p>

<h2>
<a name="flagship-features" class="anchor" href="#flagship-features"><span class="octicon octicon-link"></span></a>Flagship Features</h2>

<p>Macros allow for codes to be specified that will manipulate any S-Expressions which they begin. That is, if <code>a</code> were a macro, any S-Expression led with <code>a</code> would be passed to the macro definition prior to evaluation; an example is below. </p>

<p>Continuations were defined purely with macros. The general workflow of a continuation is to initiate a continuation statement with <code>begincc</code>, and then in the context of the statement, where the value of interest is present, to call <code>call/cc</code> with a lambda taking a continuation as a parameter. That continuation can then be set to a variable for later calling, and an initial value should be returned. Upon calling the continuation, values should be quoted (for now).</p>

<div class="highlight"><pre><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="s">" =&gt; (1 2 3)</span>
<span class="s">"</span>

<span class="p">(</span><span class="err">{</span><span class="nv">|x|</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">x</span><span class="p">)</span><span class="err">}</span> <span class="mi">5</span><span class="p">)</span>
<span class="s">" =&gt; 6</span>
<span class="s">"</span>

<span class="p">(</span><span class="nf">defmacro</span> 
  <span class="p">(</span><span class="k">let </span><span class="nv">name</span> <span class="nv">val</span> <span class="nv">body</span><span class="p">)</span> 
  <span class="o">`</span><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="o">,</span><span class="nv">name</span><span class="p">)</span> <span class="o">,</span><span class="nv">body</span><span class="p">)</span> <span class="o">,</span><span class="nv">val</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="nv">a</span> <span class="mi">5</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="mi">2</span><span class="p">))</span>
<span class="s">" =&gt; (5 2)</span>
<span class="s">"</span>

<span class="p">(</span><span class="k">define </span><span class="nv">print</span> <span class="mi">5</span><span class="p">)</span>    
<span class="p">((</span><span class="k">lambda </span>
  <span class="p">(</span><span class="nf">x</span><span class="p">)</span> 
  <span class="p">(</span><span class="nf">begincc</span> 
    <span class="p">(</span><span class="nb">write </span>
      <span class="p">(</span><span class="nb">call/cc </span><span class="err">{</span><span class="nv">|cc|</span> <span class="p">(</span><span class="k">set! </span><span class="nv">print</span> <span class="nv">cc</span><span class="p">)</span> <span class="nv">x</span><span class="err">}</span><span class="p">))))</span>
<span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print</span> <span class="o">'</span><span class="p">(</span><span class="nv">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
<span class="s">"  =&gt; 5</span>
<span class="s">"" =&gt; 6</span>
<span class="s">"</span>
</pre></div>

<h2>
<a name="syntax" class="anchor" href="#syntax"><span class="octicon octicon-link"></span></a>Syntax</h2>

<p>See examples of syntax in <code>src/test.lampas</code>. </p>

<p>For macros, after beginning with a <code>define-rewriter</code> approach, wherein macros received each S-Expression in which they were embedded as arguments, I instead opted for <code>defmacro</code>. <code>defmacro</code> parses components as arguments, but the full power of <code>define-rewriter</code> could be easily rebuilt. My implementation of macros was pretty straight-forward, each <code>defmacro</code> defined a function in the usual environment with a distinct name. From there, each S-Expression is checked for a corresponding macro name. If one is found, the tail of the S-Expression is passed as argument to the defined function. This method keeps macros hygienic. This implementation may be improper, or perhaps it has too much overhead, but it was very easily implemented.</p>

<p>I have implemented another type of macro called <code>defenvmacro</code>. <code>defenvmacro</code> receives the environment, that is, the entire context of the passed expression, as a parameter. This gives the full power of the interpreter to macros, and a simple call to <code>eval</code> could thus pick up exactly where the expression left off. Why is this special? By this method the macro exists in both its context of creation via closures and the context of the expression via <code>env</code> + <code>eval</code>. This gives it the full power of the interpreter.</p>

<h2>
<a name="compilation" class="anchor" href="#compilation"><span class="octicon octicon-link"></span></a>Compilation</h2>

<p>Compile the source using GHC and the Existential flag.</p>

<div class="highlight"><pre><span class="nv">$ </span>ghc Main.hs -XExistentialQuantification
</pre></div>

<p>Or, if on a Unix machine, run the build script which will compile, test, and clean-up. Support for Windows will be added soon.</p>

<div class="highlight"><pre><span class="nv">$ </span>./build.sh
</pre></div>

<h2>
<a name="build-script" class="anchor" href="#build-script"><span class="octicon octicon-link"></span></a>Build Script</h2>

<p>For the build script to generate documentation, it requires node.js and docco. However, if this aspect is removed it merely requires GHC.</p>

<p>The build script generates documentation, compiles all sources, removes intermediary compilation files, and then runs the test suite. All test results are of the following form in the terminal.</p>

<div class="highlight"><pre><span class="s">"# Output (= `Hello`)"</span>
<span class="s">"Hello"</span>
</pre></div>

<p>Where the asserted value is named with appropriate value in parenthesis. Tests serve to prevent unknown breaking of features.</p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>Then run the interpreter either with a program as a parameter or individually to fire up a REPL.</p>

<div class="highlight"><pre><span class="nv">$ </span>./lampas
Lampas &gt;&gt;
</pre></div>

<div class="highlight"><pre><span class="nv">$ </span>./lampas test.lampas
</pre></div>

<p>Include the library functions with the following.</p>

<div class="highlight"><pre><span class="o">(</span>load <span class="s2">"Prelude.lampas"</span><span class="o">)</span>
</pre></div>

<h2>
<a name="upcoming-features" class="anchor" href="#upcoming-features"><span class="octicon octicon-link"></span></a>Upcoming Features</h2>

<ul>
<li>
<code>,@</code> unquote-splicing</li>
<li>
<code>case</code> statements</li>
<li><code>currying</code></li>
<li>
<code>continuations</code> - the last component of continuations that needs to be implemented is continuation of the stack, rather than the current mere re-evaluation of the expression. I think as an intermediary implementation I'll have <code>begincc</code> accept a variable number of expressions over which it will operate. Values are also immutable right now! The only solution I foresee existing for this is to overwrite the <code>set!</code>, <code>define</code>, etc. functions when performing the <code>evalenv</code>; this should not be too hard.</li>
<li><code>numerical tower</code></li>
</ul><h2>
<a name="references" class="anchor" href="#references"><span class="octicon octicon-link"></span></a>References</h2>

<ul>
<li>This is very much thanks to the tutorial <a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">Write Yourself a Scheme in 48 Hours</a> by <em>Jonathan Tang</em>. It makes quite clear how to implement a language in Haskell, developing a REPL early on and building it up to a full-fledged Scheme.</li>
<li>Fogus' <a href="https://github.com/fogus/caerbannog">Caerbannog</a>.</li>
<li>An introduction to continuations in Scheme, <a href="http://dunsmor.com/lisp/onlisp/onlisp_24.html">On Continuations</a>.</li>
<li>A discussion of macros in Scheme and Lisp, <a>On Macros</a>
</li>
</ul>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/Linguae">Linguae</a> can be found on <a href="https://github.com/Linguae/Lampas">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

    
  </body>
</html>
