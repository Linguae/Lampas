(load "src/Prelude.lampas")

" Builtin to the book's Language (Tarpits & Abstraction)
"
(define 
  (set key val hash)
  (push (map
    (lambda (item)
      (if
        (equal? (car item) key)
        (list key val)
        item))
    hash) (list key val)))
(define (assocv key hash) (if (eqv? #f (assoc key hash)) '() (cadr (assoc key hash))))
(define (cond-set conds)
  (if
    (null? conds)
    '#f
    (list 
      (list 
        'lambda 
	'(found) 
	(list 'if 'found (cadar conds) (cond-set (cdr conds)))) 
      (car (car conds)))))
(defmacro (cond conds) (cond-set conds))
(define
  (let-set vars expr)
  (if
    (null? vars)
    expr
    (list (list 'lambda (list (car (car vars))) (let-set (cdr vars) expr)) (car (cdr (car vars))))))
(defmacro (let* vars expr) (let-set vars expr))
(defmacro (let key val expr) `((lambda (,key) ,expr) ,val))


" Register Machine
"
(define (get lst index)
  (if
    (null? lst)
    '(halt)
    (if
      (eqv? index 0)
      (car lst)
      (get (cdr lst) (- index 1)))))
(define (eval exprs env index)
  (write (get exprs index))
  (let 
    expr 
    (get exprs index)
    (cond (((eqv? (car expr) 'jmp) (eval exprs env (assocv (cadr expr) env)))
           ((eqv? (car expr) 'call) (let stack (assocv 'stack env) (eval exprs (set 'stack (cons (+ 1 index) stack) env) (assocv (cadr expr) env))))
	   ((eqv? (car expr) 'push) (eval exprs (set 'args (cons (cadr expr) (assocv 'args env)) env) (+ 1 index)))
	   ((eqv? (car expr) 'pushp) (eval exprs (set 'args (cons (assocv (cadr expr) env) (assocv 'args env)) env) (+ 1 index)))
	   ((eqv? (car expr) 'pop) (let args (assocv 'args env) (eval exprs (set 'args (cdr args) (set (cadr expr) (car args) env)) (+ 1 index))))
           ((eqv? (car expr) 'set) (eval exprs (set (cadr expr) (caddr expr) env) (+ 1 index)))
           ((eqv? (car expr) 'cp) (eval exprs (set (cadr expr) (assocv (caddr expr) env) env) (+ 1 index)))
           ((eqv? (car expr) 'incr) (eval exprs (set (cadr expr) (+ 1 (assocv (caddr expr) env)) env) (+ 1 index)))
	   ((eqv? (car expr) 'ret) (let stack (assocv 'stack env) (eval exprs (set 'stack (cdr stack) env) (car stack))))
	   ((eqv? (car expr) 'comment) (eval exprs env (+ 1 index)))
	   ((eqv? (car expr) 'halt) env)))))
(define (enumerate exprs num)
  (if
    (null? exprs)
    '()
    (if
      (eqv? (car (car exprs)) 'label)
      (cons (push (car exprs) num) (enumerate (cdr exprs) num))
      (cons (push (car exprs) num) (enumerate (cdr exprs) (+ 1 num))))))
(define (init-env exprs)
  (concat (map (lambda (label) (cdr label)) (filter (lambda (expr) (eqv? (car expr) 'label)) (enumerate exprs 0))) '((stack ()) (args ()))))
(define (remove-labels exprs)
  (filter (lambda (expr) (not (eqv? (car expr) 'label))) exprs))  
(define (init-index env)
  (assocv 'main env))  
" example: (((lambda (x) (lambda (y) (x y))) (lambda (x) x)) 2)
"	   
(define 
  assembly 
  '((label incr)
    (comment (x -> x+1))
    (pop x)
    (incr resp x)
    (ret)
 
    (label dechurch)
    (comment (renders a church numeral as an int))
    (pop n)
    (pushp incr)
    (push 0)
    (call n)
    (ret)

    (label two)
    (comment (f -> x -> (f (f x))))
    (pop x)
    (pop f)
    (pushp x)
    (call incr)
    (pushp resp)
    (call incr)
    (ret)
  
    (label lam1)
    (comment (x -> x))
    (pop x)
    (cp resp x)
    (ret)

    (label lam2)
    (comment (x -> y -> (x y)))
    (pop y)
    (pop x)
    (pushp y)
    (call x)
    (ret)

    (label lam3)
    (comment (x -> lam2))
    (cp resp lam2)
    (ret)

    (label main)
    (comment (typed as int (lam1 lam3 two)))
    (pushp lam1)
    (call lam3)
    (pushp two)
    (call resp)
    (pushp resp)
    (call dechurch)))    

(define env (init-env assembly))
(define index (init-index env))
(define exprs (remove-labels assembly))

(write (assocv 'resp (eval exprs env index)))
